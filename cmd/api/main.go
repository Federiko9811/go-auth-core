// Package main Go Auth Core API
//
// API for passkey-only authentication based on WebAuthn and JWT.
//
//	@title			Go Auth Core API
//	@version		1.0
//	@description	WebAuthn/Passkey Authentication API with HttpOnly JWT cookies
//
//	@contact.name	API Support
//	@contact.email	support@example.com
//
//	@license.name	MIT
//	@license.url	https://opensource.org/licenses/MIT
//
//	@host		localhost:8080
//	@BasePath	/
//
//	@securityDefinitions.apikey	CookieAuth
//	@in							cookie
//	@name						access_token
//	@description				JWT token in HttpOnly cookie (set automatically on login)
package main

import (
	"github.com/gin-gonic/gin"
	redis2 "github.com/redis/go-redis/v9"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	"go-auth-core/internal/api"
	"go-auth-core/internal/conf"
	"go-auth-core/internal/domain"
	"go-auth-core/internal/repository"
	"go-auth-core/internal/service"
	"go-auth-core/pkg/database"
	"go-auth-core/pkg/email"
	"go-auth-core/pkg/logger"
	"go-auth-core/pkg/redis"

	_ "go-auth-core/docs" // Swagger docs generated by swag init
)

func main() {
	// 1. Configuration
	cfg := conf.LoadConfig()

	// 2. Initialize Logger
	logger.Init(cfg.LogLevel, cfg.LogFormat)
	logger.Info("üîß Config loaded: App running on port " + cfg.AppPort)

	// 3. Database Setup
	db, err := database.NewPostgresDB(cfg)
	if err != nil {
		logger.Fatal("Could not connect to the database", err)
	}

	// Auto-migration
	if err := db.AutoMigrate(&domain.User{}, &domain.Passkey{}); err != nil {
		logger.Fatal("Failed to migrate database", err)
	}
	logger.Info("‚úÖ Database migrated successfully")

	// 4. Redis Setup
	rdb, err := redis.NewRedisClient(cfg)
	if err != nil {
		logger.Fatal("Could not connect to redis", err)
	}
	defer func(rdb *redis2.Client) {
		if err := rdb.Close(); err != nil {
			logger.Error("Error closing redis client", err)
		}
	}(rdb)
	logger.Info("‚úÖ Redis connected successfully")

	// 5. Initialize Repositories
	userRepo := repository.NewUserRepository(db)
	passkeyRepo := repository.NewPasskeyRepository(db)
	redisRepo := repository.NewRedisRepository(rdb)

	// 6. Initialize Services
	emailSender := email.NewGomailSender(cfg) // Create Email Sender
	authService, err := service.NewAuthService(userRepo, passkeyRepo, redisRepo, emailSender, cfg)
	if err != nil {
		logger.Fatal("Failed to initialize AuthService", err)
	}
	logger.Info("‚úÖ Services initialized")

	// 7. Initialize Handlers
	authHandler := api.NewAuthHandler(authService, userRepo, cfg)
	passkeyHandler := api.NewPasskeyHandler(passkeyRepo)
	healthHandler := api.NewHealthHandler(db, rdb)

	// 8. Router Setup
	if cfg.Env == "production" {
		gin.SetMode(gin.ReleaseMode)
	}
	r := gin.New() // Use New() instead of Default() for full middleware control

	if err := r.SetTrustedProxies(nil); err != nil {
		logger.Fatal("Failed to set trusted proxies", err)
	}

	// --- MIDDLEWARE (order matters!) ---

	// 1. Recovery (panics catcher)
	r.Use(gin.Recovery())

	// 2. Request Logger (structured logs)
	r.Use(logger.RequestLoggerMiddleware())

	// 3. CORS (before rate limiter to handle preflight)
	r.Use(api.CORSMiddleware(cfg.CORSOrigins))

	// 4. Rate Limiter (DDoS protection)
	r.Use(api.RateLimiterMiddleware(rdb, cfg.RateLimitRequests, cfg.RateLimitWindowSeconds))

	// --- ROUTES ---

	// Health check (excluded from rate limiting in middleware logic if implemented there, or lightweight enough)
	r.GET("/", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "Go Auth Core API üöÄ",
			"status":  "healthy",
		})
	})

	// Detailed Health Check
	r.GET("/health", healthHandler.Health)

	// Swagger UI - API Documentation
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Public Routes (Authentication)
	auth := r.Group("/auth")
	{
		auth.POST("/register/begin", authHandler.RegisterBegin)
		auth.POST("/register/verify-otp", authHandler.RegisterVerifyOTP) // New endpoint
		auth.POST("/register/finish", authHandler.RegisterFinish)
		auth.POST("/login/begin", authHandler.LoginBegin)
		auth.POST("/login/finish", authHandler.LoginFinish)
		auth.POST("/refresh", authHandler.RefreshToken)
		auth.POST("/logout", authHandler.Logout)
	}

	// Protected Routes (Require Authentication)
	protected := r.Group("/api")
	protected.Use(api.JWTMiddleware(cfg.JWTSecret))
	{
		// User info
		protected.GET("/me", authHandler.Me)

		// Passkey management
		protected.GET("/passkeys", passkeyHandler.List)
		protected.PATCH("/passkeys/:id", passkeyHandler.Rename)
		protected.DELETE("/passkeys/:id", passkeyHandler.Delete)
	}

	// 9. Start Server
	logger.Info("üöÄ Server starting on http://localhost:" + cfg.AppPort)
	logger.Info("üìç Endpoints:")
	logger.Info("   POST /auth/register/begin  - Start passkey registration")
	logger.Info("   POST /auth/register/finish - Complete registration")
	logger.Info("   POST /auth/login/begin     - Start passkey login")
	logger.Info("   POST /auth/login/finish    - Complete login (sets cookies)")
	logger.Info("   POST /auth/refresh         - Refresh access token")
	logger.Info("   POST /auth/logout          - Clear auth cookies")
	logger.Info("   GET  /api/me               - Get current user (protected)")
	logger.Info("   GET  /api/passkeys         - List passkeys (protected)")
	logger.Info("   PATCH /api/passkeys/:id    - Rename passkey (protected)")
	logger.Info("   DELETE /api/passkeys/:id   - Delete passkey (protected)")
	logger.Info("   GET  /health               - Detailed health check")
	logger.Info("   GET  /swagger/index.html   - API Documentation üìö")

	if err := r.Run(":" + cfg.AppPort); err != nil {
		logger.Fatal("Server failed to start", err)
	}
}
